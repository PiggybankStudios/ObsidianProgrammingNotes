## Notes
- [ ] [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html)
- [ ] [Tomorrow Corporation Rust Gamedev Blog Post](https://loglog.games/blog/leaving-rust-gamedev/)
- [ ] I seemed to have messed with Rust in **August 2023**, On Desktop: `C:/gamedev/projects/LearningRust`
- [ ] Rust Compiler and Cargo (and other tools) are installed in `C:\Users\robbitay\AppData\Local\.cargo\bin` as `rustc.exe
- [ ] Ricky recommends the following UI library ["EGUI"](https://github.com/emilk/egui) and [template](https://github.com/emilk/eframe_template)
- [ ] `cargo run --release`
- [ ] [TrunkRS.dev](https://trunkrs.dev/)
- [ ] 
## Basic Syntax Notes
- [ ] Function Declaration: `fn modify_value(value: &mut i32) { *value += 5; }`
- [ ] Debug output `println!("Hello World!");` (! means println is a macro)
- [ ] Pass a mutable reference to a function by doing `funtionCall(&mut variable)`
- [ ] Variable declaration/assignment: `let mut x: u8 = 10;`
- [ ] Disable warning on a particular function by prefixing with: `#[allow(unused_parens)]`
- [ ] Disable unused variable warning with `#[allow(unused_variables)]` OR name the variable with a leading underscore `_unused_variable` or simply use an `_` as the entire name
- [ ] Parentheses around if condition are not required and are treated as a warning by default
- [ ] All names are expected to be snake_case and a warning is generated by default when a non-snake_case name is detected
- [ ] Closure syntax: `|arg1, arg2| { ... }`
- [ ] Integer Types: `i8, i16, i32, i64, i128, u8, u16, u32, u64, u128`
- [ ] Float Types: `f32, f64`
- [ ] Suffix number literals with type: `255u8` or `1.0f32`
- [ ] Array declaration: `let array: [i32; 3] = [1, 2, 3];` (get length with `.len()`, get iterator with `.iter()`, get index+value tuple with `.iter().enumerate()`)
- [ ] Format strings in Rust can contain `{}` to indicate automatic formatting of the next argument
- [ ] Disable dead code warning with `#[allow(dead_code)]`, allow unused imports with `#[allow(unused_imports)]`
- [ ] Call constructor for a struct `let mut map = HashMap::new();`
- [ ] Import a type: `use std::collections::HashMap;`
- [ ] Switch on enum type: (all values of enum must be handled in a `match`)
```rust
match enum_value
{
	EnumValue1(inner_value) => { ... }
	EnumValue2(inner_value) => { ... }
}
```
- [ ] Loop over elements in HashMap with borrowed reference: `for (key, value) in &map { ... }`
- [ ] `Option<T>` acts as the optional type, where the value may or may not exist. This is returned by dictionary `.get(key)` function. You can access the value (assuming it exists) with `.unwrap()`. `Option` is either `Some` or `None`
- [ ] Declare a function to explicitly not return anything: `fn my_func() -> () { ... }`
- [ ] Use `match` with `Some(inner)` and `None` entries to unwrap `Option<T>` safely
- [ ] `Result` works like `Option` but with `Ok` or `Err`. `match` and `.unwrap()` both work on `Result`
- [ ] `.expect("Error message")` works like `.unwrap()` but throws a panic if the result an `Err`. Also can use `.is_err()`
- [ ] Throw an error: `panic!("Error message");`
- [ ] 
## Rust Compiler CLI Options `rustc` [Link](https://doc.rust-lang.org/rustc/command-line-arguments.html)
- [ ] `-g` / `-C debuginfo=2`: Generate debug symbols
- [ ] `-o "app.exe"`: change the name of the output executable
- [ ] `--out-dir [DIR]`: Write the output to a particular directory
- [ ] `-O` / `-C opt-level=2`: Turn on compiler optimizations
- [ ] `-C OPT[=VALUE]`: Change a codegen option to a particular value
- [ ] `-L [KIND=]PATH`: Add a library search directory
	- `KIND` can be `dependency`, `crate`, `native`, or `all`
- [ ] `-l [KIND[:MODIFIERS]=]NAME[:RENAME]`: Link to a specified native library
	- `KIND` can be `static`, `framework` or `dylib`
	- `MODIFIERS` can be `bundle`, `verbatim`, `whole-archive` or `as-needed` (with `+` and `-` prefix to enable/disable)
- [ ] `--target [TARGET]`: Determines what target to compile for, like `x86_64-pc-windows-msvc` or `wasm32-unknown-unknown` (run `rustc --print target-list` for all options)
- [ ] `--crate-type [type]`: Comma separated list of crate types for the compiler to emit
	- Possible values: `bin`, `lib`, `rlib`, `dylib`, `cdylib`, `staticlib`, `proc-macro`
- [ ] `--crate-name NAME`: Specify the name of the crate being built
- [ ] `--edition [2015|2018|2021|2024]`: Specify which edition of the copiler to use, default is `2015`
- [ ] `--emit [type]`: Comma separated list of types for the compiler to emit
	- Possible values: `asm`, `llvm-bc`, `llvm-ir`, `obj`, `metadata`, `link`, `dep-info`, `mir`
- [ ] `--print [type]`: Compiler debug information to print to stdout
	- Possible values: `crate-name`, `file-names`, `sysroot`, `target-libdir`, `cfg`, `calling-conventions`, `target-list`, `target-cpus`, `target-features`, `relocation-models`, `code-models`, `tls-models`, `target-spec-json`, `all-target-specs-json`, `native-static-libs`, `stack-protector-strategies`, `link-args`, `deployment-target`
- [ ] s
## Cargo CLI Options
- [ ] `cargo new [folder_name]`: Creates a folder in this current directory and adds a Cargo.toml, src folder, main.rs, and a .gitignore file (also can use `cargo init` to make a cargo project in the current directory)
- [ ] `cargo [run/build] {--release}`: In the folder with the Cargo.toml, this compiles the application (if needed), and runs it if `run` is used
- [ ] 
## Useful Crates
- [ ] [serde](https://crates.io/crates/serde) A generic serialization/deserialization framework
	- [serde_json](https://crates.io/crates/serde_json)
- [ ] [glfw](https://crates.io/crates/glfw) GLFW3 bindings and idiomatic wrapper for Rust
	- [glfw-passthrough](https://crates.io/crates/glfw-passthrough)?
- [ ] [egui](https://crates.io/crates/egui) An easy-to-use immediate mode GUI that runs on both web and native [Github](https://github.com/emilk/egui) [Web Demo](https://www.egui.rs/#demo)
- [ ] 
## Rust in Python pip Packages [Book on Amazon](https://www.amazon.com/Speed-Your-Python-Rust-performance/dp/180181144X) [Github](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust)
- [ ] Software covered in the book: Python 3, Rust, Docker, Py03, Redis, PostgreSQL
- [ ] [Color Images](https://static.packt-cdn.com/downloads/9781801811446__ColorImages.pdf)
- [ ] [Free Online Python Interpreter](https://replit.com/languages/python3)
- [ ] [Free Online Rust Compiler](https://play.rust-lang.org)
- [ ] [nVidia CEO Moore's Law is Dead Article](https://www.cnet.com/news/moores-law-is-dead-nvidias-ceo-jensen-huang-says-at-ces-2019)
- [ ] [Why Discord is Switching from Go to Rust](https://discord.com/blog/why-discord-is-switching-from-go-to-rust)
- [ ] `str` and `String` are not the same thing. `str` is the data stored in the heap, where String is a wrapper that lives on the stack. We can convert a literal to a string with `.to_string()` or `String::from(str)`
- [ ] All variables are immutable by default, we must use the `mut` keyword to declare a mutable variable
- [ ] Adding integer literal to float literal results in an error!
- [ ] A mix of structs can be stored in an array if they all share a **trait**
- [ ] `let mut my_vector: Vec<&str> = vec!["one", "two", "three"];`
- [ ] Array: `.len()`, `.iter()`, `.enumerate()`
- [ ] Vector: `.len()`, `.iter()`, `.enumerate()`, `.push(value)`
- [ ] Python enums:
```python
from enum import Enum
class Animal(Enum):
	Cow = "Cow"
	Goat = "Goat"
```
- [ ] The full type of a declared variable may be inferred using context after the declaration. For example we can declare an unqualified HashMap variable and then later when we call `.insert` on that HashMap, the type of the arguments in that call can determine the type of the HashMap
- [ ] We have to follow Rust rules regarding: copying, moving, immutable borrowing, and mutable borrowing
	- **Copy**: The variable is copied into a new variable, both variables own their copy of the data. This happens for basic types like integers when using them in algebraic expressions. If the type doesn't have the `Copy` attribute then it must be **moved**. `String` does not have `Copy` trait
	- **Move**: The data is moved from one variable to another, the old variable cannot be used anymore. 
	- **Immutable Borrow**: A new variable that references the existing variable is created. When the borrowed variable goes out of scope the original variable becomes mutable again. Original variable can still be copied and borrowed while the second variable is alive, but we can't move or mutable borrow it. Designated with `&` character prefixed to the type and variable being passed
	- **Mutable Borrow**: Similar to immutable borrow but the original variable is entirely locked down while the second variable is alive, it can't be copied or borrowed. This also allows the new variable to change the value in memory. Designated with `&mut` prefixed to type and variable being passed
- [ ] Borrowed values are dereferenced using `*` prefix, like dereferencing a pointer in C/C++
- [ ] A borrowed variable type can be passed to a binary operator like `>` without a dereference?
- [ ] The `'` character is used to denote lifetimes. We can add a name after the quote to give the lifetime a name, like `'lifetime_a`
- [ ] I guess we can do something like `&0` to get a new reference to a integer literal, and I guess the lifetime of that reference can be coerced because we are returning it with the guarantee it has the lifetime of a reference that was passed in
- [ ] `struct` members are separated by commas, not semicolons. A trailing comma is permitted
- [ ] integer literals are not coerced to floats even when the left-hand side of the equation is a float
- [ ] Mutability applies to struct members as well, so if the variable is not marked as `mut` then we can't change any of it's members after it's created
- [ ] We can access and change members of the immutable struct as long as the declaration+assignment line has not ended. So a common pattern is something like `let immut_struct = Type::new(...).with_extra(...).with_more(...);` where we have function calls chain together to build all the members out before the line ends
- [ ] It seems like member functions in a struct can have a sort of "special" first argument: `mut self` which has an implied type. We can also do `&self` to get a borrowed immutable reference to self.
- [ ] We can apply the `#[allow(dead_code)]` attribute to a `struct` member, or applying it to the whole `struct` will allow all members to be allowed when dead and the `struct` itself
- [ ] When defining a type, we can use the `impl` keyword following by a Trait to say we want any type that implements that Trait. `fn process_transfer(stock: impl CanTransfer) { ... }`
- [ ] We can initialize a struct without a `::new` function using curly brackets after the type name: `let pos = Vector2{x: 1, y: 2};`
- [ ] We can use `#[derive(Copy, Clone)]` on a struct to automatically implement the Copy and Clone traits. Especially useful for stuff like `struct Vector2<T> {...}` where the members are all copyable/clonable types
- [ ] When doing curly bracket initialization of a type, we cannot use `<Type>` to declare template types. We have to declare them on the left-hand side of the assignment `let x: Vector2<i64> = Vector2{x: 1, y: 2};`
- [ ] The last line in a function is implicitly treated as the return value **if it does not have an ending semicolon!**
- [ ] Cargo does a lot of things: Building, Running, Package Downloading, Testing, Documentation Generation, etc.
- [ ] All Cargo output is put into the `target/` folder next to the `Cargo.toml` (except for `Cargo.lock` file? Should we include this in the repository?)
- [ ] Distribution of crates is often done through [Crates.io](https://crates.io/)
- [ ] 